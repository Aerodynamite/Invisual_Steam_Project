<!DOCTYPE html>

<html>
<head>
    <title>Invisual Project</title>
	<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
    <script src="data1-1600.json"></script>

    <style>
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            margin: auto;
            position: relative;
            width: 960px;
        }
        text {
            font: 10px sans-serif;
        }
        .axis path {
            display: none;
        }

        .axis line {
            shape-rendering: crispEdges;
            stroke: #000;
        }

        .axis .minor line {
            stroke: #777;
            stroke-dasharray: 5,4;
        }

        form {
            position: absolute;
            right: 10px;
            top: 10px;
        }

        /*Legend*/
        .legend {
            font-size: 70px;
        }
        rect {
            stroke-width: 2;
        }
    </style>

</head>

<form>
    <label><input type="radio" name="mode" value="grouped"> Grouped</label>
    <label><input type="radio" name="mode" value="relative"> Relative</label>
    <label><input type="radio" name="mode" value="stacked" checked> Absolute</label>
    <label><input type="radio" name="mode" value="compare"> Compare</label>
</form>

<body>

<h1> Visualization Invisual  </h1>

<div id="id01"></div>

    <script>
    	$.getJSON("data1-1600.json", function(json) {
//    	$.getJSON("data1-16387.json", function(json) {
//        console.log("JSON data");
//        console.log(json); // this will show the info it in firebug console

            var genres = [];
   			var dataQs = combineAndSortGenresAndDates(json, genres);

            var dataYear = FromQsToYears(dataQs);

            visualise(dataQs, dataYear, genres);
		});

        // genres is used to RETURN the genres
        function combineAndSortGenresAndDates(json, genres) {
            // Melvin code 2
            var all_genres = [];
            var found;
            for (var it1 = 0; it1 < json.length; it1++) {
                var game = json[it1].genres;
                var date = json[it1].releaseDate;
                var date_array = date.split(" ");
                var month = date_array[1];
                var year = date_array[2];

                for (var it2 = 0; it2 < game.length; it2++) {
                    var genre = game[it2].description;
                    //search the current genre in the list of the genres already counted, when found increase it's counter by 1
                    found = false;
                    for (var it3 = 0; it3 < all_genres.length && !found; it3++) {
                        if (all_genres[it3].name.localeCompare(genre) == 0 && year == all_genres[it3].year && month == all_genres[it3].month) {
                            all_genres[it3].amount++;
                            found = true;
                        }
                    }
                    //if the genre is not found in the array, make a new entry and put it's counter on 1
                    if (!found) {
                        all_genres.push({
                            "name":genre,
                            "amount":1,
                            "month":month,
                            "year":year
                        });
                    }
                }
            }
            all_genres.sort(function (a, b) {
                if (a.year > b.year) {
                    return -1;
                }
                if (a.year < b.year) {
                    return 1;
                }
                // a must be equal to b
                return 0;});

            all_genres.sort(function (a, b) {
                if (a.month > b.month) {
                    return -1;
                }
                if (a.month < b.month) {
                    return 1;
                }
                // a must be equal to b
                return 0;});

//            console.log("Melvin object");
//            console.log(all_genres);

 		    // convert to suitable object for visualisation
            var data = [];
            for (var i = 0; i < all_genres.length; i++) {
                var genre = all_genres[i].name;
                var month = all_genres[i].month;
                var year = parseInt(all_genres[i].year);
                var amount = all_genres[i].amount;

                if (!isNaN(year)) { // make sure the year is a number

                    // if genre already in data, it has been handled before
                    var found = false;
                    for (var j = 0; j < data.length; j++) {
                        if (data[j].genre == genre) {
                            found = true;
                        }
                    }

                    if (!found) {
                        // Add current year to data
                        data.push({
                            games: [
                                {
                                    x: year,
                                    x0: month,
                                    y: amount
                                }
                            ],
                            total: amount,
                            genre: genre
                        });

                        // search the current genre in future years of all_genres
                        // start from next position in i, to avoid double counting
                        for (var j = i + 1; j < all_genres.length; j++) {
                            if (all_genres[j].name == genre) {
                                var newYear = parseInt(all_genres[j].year);
                                if (!isNaN(newYear)) {
                                    var newMonth = all_genres[j].month;
                                    var newAmount = all_genres[j].amount;
                                    data[data.length - 1].games.push({x: newYear, x0:newMonth, y: newAmount});
                                    data[data.length - 1].total += newAmount;
                                }
                            }
                        }
                    }
                }
            }

            // sort the genres from most games to least games
            data.sort(function (a, b) {
                if (a.total > b.total) {
                    return -1;
                }
                if (a.total < b.total) {
                    return 1;
                }
                // a must be equal to b
                return 0;}
            );

            // put the names of the genres in a list
            for (var i = 0; i < data.length; i++) {
                genres.push(data[i].genre);
            }

            // sort the games of each genre from old to new using year and month
            for (var genre = 0; genre < data.length; genre++) {
                data[genre].games.sort(function (a, b) {
                    if (a.x < b.x)
                        return -1;
                    if (a.x > b.x)
                        return 1;
                    if(a.x == b.x) {
                        var ma = MonthtoNum(a.x0);
                        var mb = MonthtoNum(b.x0);
                        if (ma < mb)
                            return -1;
                        if (ma > mb)
                            return 1;
                    }
                    return 0;
                });
            }

            /*// add the missing years + months to each genre
            for (var genre = 0; genre < data.length; genre++) {
                var newGames = [];
                var prevYear = 1997;
                for (var year = 0; prevYear < 2015; ) {
                    // if the current existing year, isn't the successor of the previous year
                    if (year < data[genre].games.length && data[genre].games[year].x > prevYear + 1
                        || year >= data[genre].games.length && prevYear < 2015) {
                        // add the year to the array with a count of 0 games
                        newGames.push({
                            x: prevYear+1,
                            x0:
                            y: 0
                        });
                    }
                    else { // current year is the successor
                        // add to array
                        newGames.push(data[genre].games[year]);
                        year++; // go to next year in existing array
                    }
                    prevYear++;
                }
                data[genre].games = newGames;
            }*/

            //divide the months in Q's and add the missing ones
            var dataQs = [];
            for (var genreIt = 0; genreIt < data.length; genreIt++) {
                var length = data[genreIt].games.length;
                var newGames = [];
                var prevYear = 2005;
                var prevQ;

                var yearIt = 0;
                //because we skip a couple of years in the graph we also need to skip a couple of years in the games array
                while(yearIt < length && data[genreIt].games[yearIt].x < 2005)yearIt++;

                while (prevYear <= 2015) {
                    prevQ = 1;
                    while (prevQ < 5) {
                        newGames.push({
                            x: prevYear,
                            q: prevQ,
                            y: 0
                        });

                        while (yearIt < length && MonthToQ(MonthtoNum(data[genreIt].games[yearIt].x0)) == prevQ && data[genreIt].games[yearIt].x == prevYear) {
                            newGames[(prevQ-1) + (prevYear-2005)*4].y += data[genreIt].games[yearIt].y;
                            yearIt++;
                        }
                        prevQ++;
                    }
                    prevYear++;
                }
                dataQs.push({
                    games: newGames,
                    total: data[genreIt].total,
                    genre: data[genreIt].genre
                });
            }

/*            console.log("Data");
            console.log(data);
            console.log("Data Q's");
            console.log(dataQs);*/

            return dataQs;
        }

        function FromQsToYears(dataQs) {
            //simplify the data (filter out the months)
            var dataYears = [];

            for (var genreIt = 0; genreIt < dataQs.length; genreIt++) {
                var newGames = [];
                var prevYear = 2005;

                var yearIt = 0;
                while (prevYear <= 2015) {
                    newGames.push({
                        x: prevYear,
                        y: 0
                    });

                    var prevQ = 1;
                    while (prevQ < 5) {
                        newGames[yearIt].y += dataQs[genreIt].games[yearIt * 4 + (prevQ - 1)].y;
                        prevQ++;
                    }
                    yearIt++;
                    prevYear++;
                }
                dataYears.push({
                    games: newGames,
                    total: dataQs[genreIt].total,
                    genre: dataQs[genreIt].genre
                });
            }

/*            console.log("dataYears");
            console.log(dataYears);*/

            return dataYears;
        }


        /**
         * @return {number}
         */
        function MonthtoNum(name) {
            var n;
            var numMonth = 1;
            n = name.localeCompare("Jan,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Feb,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Mar,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Apr,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("May,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Jun,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Jul,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Aug,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Sep,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Oct,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Nov,")
            if(n == 0)
                return numMonth;
            numMonth++;
            n = name.localeCompare("Dec,")
            if(n == 0)
                return numMonth;
        }

        function MonthToQ(x) {
            return (((x-1) - (x-1)%3) / 3)+1
        }

        //////////////// VISUALIZATION
        function visualise(dataQs, dataYear, genres) {
/*            console.log("dataQs");
            console.log(dataQs);
            console.log("dataYear");
            console.log(dataYear);*/
            var n = 5, // number of layers (= # genres)
                m = 18, // number of samples per layer (= # years)
                stack = d3.layout.stack(),
                genreCounter = 0;
            var layersYear = stack(d3.range(n).map(function() {
//                    console.log(temp);
                        var ret = dataYear[genreCounter].games;
                        genreCounter = genreCounter + 1;
//                    console.log(ret);
                        return ret;
                    }));
            //boolean to check if we need to make a transition from line- to barchart
            var wasLine = false;

            genreCounter = 0;
            var layersQ = stack(d3.range(n).map(function() {
                        var ret = dataQs[genreCounter].games;
                        genreCounter = genreCounter + 1;
                        return ret;
                    }));

            var yGroupMaxYear = d3.max(layersYear, function(layer) { return d3.max(layer, function(d) { return d.y; }); });
            var yRelativeMax = 100;
            var yStackMaxYear = d3.max(layersYear, function(layer) { return d3.max(layer, function(d) { return d.y0 + d.y; }); });
            var yCompareMax = d3.max(layersQ, function(layersQ) {return d3.max(layersQ, function(d) {return d.y; }); });

            /*
            console.log("layersYear");
            console.log(layersYear);
            console.log("layersQ");
            console.log(layersQ);
            */

            var amountGamesYear = [];
            var amountYear = dataYear[0].games.length;
            var it = 0;
            while(it < amountYear){
                amountGamesYear.push(0.00000000000000000001);
                it++;
            }

            for(var it1 in layersYear) {
                for(var it2 in layersYear[it1])
                    amountGamesYear[it2] = amountGamesYear[it2] + layersYear[it1][it2].y;
            }

//            console.log(amountGamesYear);

            var margin = {top: 40, right: 100, bottom: 20, left: 50},
                    width = 1024 - margin.left - margin.right,
                    height = 500 - margin.top - margin.bottom;

            var x = d3.scale.ordinal()
                    .domain([2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015])
                    .rangeRoundBands([0, width], .08);

            var y = d3.scale.linear()
                    .domain([0, yStackMaxYear])
                    .range([height, 0]);

            var xq = d3.scale.ordinal()
                    .domain([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44])
                    .rangeRoundBands([0, width], .08);


            var colorArray = ["#538ed5", "#953735", "#e46d0a", "#75923c", "#b2a1c7", "#dc143c", "#87cefa",
                "#90ee90", "#add8e6", "#d3d3d3", "#cf1256", "#12cf5e"];

            var color = d3.scale.ordinal()
                    .range(colorArray);

//            var color = d3.scale.linear()
//                    .domain([0, n - 1])
//                    .range(["#aad", "#556"]);

            var xAxis = d3.svg.axis()
                    .scale(x)
                    .tickSize(0)
                    .tickPadding(6)
                    .orient("bottom");

            var yAxis = d3.svg.axis()
                    .scale(y)
                    //.ticks(5)
                    //.tickFormat(formatAmount)
                    .tickSize(-width)
                    .tickPadding(2)
                    .orient("left");

            var svg = d3.select("body").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var layer = svg.selectAll(".layer")
                    .data(layersYear)
                    .enter().append("g")
                    .attr("class", "layer")
                    .style("fill", function(d, i) { return color(i); });

            var rect = layer.selectAll("rect")
                    .data(function(d) { return d; })
                    .enter().append("rect")
                    .attr("x", function(d) { return x(d.x); })
                    .attr("y", height)
                    .attr("width", x.rangeBand())
                    .attr("height", 0);

//---------------------------lines aanmaken-------------------------


            var city = svg.selectAll(".city")
                    .data(layersQ)
                    .enter().append("g")
                    .attr("class", "city");


            var line = d3.svg.line()
                    .interpolate("basis")
                    .x(function(d) { return xq(d.q + (d.x-2005) * 4); })
                    .y(function(d) { return y(d.y); });

            var lineinX = d3.svg.line()
                    .interpolate("basis")
                    .x(function(d) { return xq(d.q + (d.x-2005) * 4); })
                    .y(function() { return height; });

            var lines = city.append("path")
                    .attr("class", "line")
                    .attr("d", function(d) { return lineinX(d); })
                    .attr("stroke", function(d, i) { return color(i); })
                    .attr("stroke-width", 0)
                    .attr("fill", "none");


//----------------------------------------------------------

//----------------------text maken--------------------------
            var maxSizeText = 70;

            var text = layer.selectAll("text")
                    .data(function(d) { return d; })
                    .enter()
                    .append("text")
                    .attr("x", function(d) { return x(d.x) + x.rangeBand()/2-(maxSizeText * d.y/yStackMaxYear)/2;})
                    .attr("y", height)
                    .text(function(d) { return d.y })
                    .style("font-size", function(d) {return maxSizeText * d.y/yStackMaxYear + "px"})
                    .attr("fill", "black");

//----------------------------------------------------------

//----------------------legende maken-----------------------

            var legendRectSize = 18;
            var legendSpacing = 4;

            var legend = svg.selectAll('.legend')
                    .data(color.domain())
                    .enter()
                    .append('g')
                    .attr('class', 'legend')
                    .attr('transform', function(d, i) {
                        var height = legendRectSize + legendSpacing;
                        var horz = width + 10;
                        var vert = i * height - 0;
                        return 'translate(' + horz + ',' + vert + ')';
                    });

            legend.append('rect')
                    .attr('width', legendRectSize)
                    .attr('height', legendRectSize)
                    .style('fill', color)
                    .style('stroke', color);

            legend.append('text')
                    .attr('x', legendRectSize + legendSpacing)
                    .attr('y', legendRectSize - legendSpacing)
                    .text(function(d) { return genres[d]; });

//----------------------------------------------------------

            rect.transition()
                    .delay(function(d, i) { return i * 10; })
                    .attr("y", function(d) { return y(d.y0 + d.y); })
                    .attr("height", function(d) { return y(d.y0) - y(d.y0 + d.y); });

            text.transition()
                    .delay(function(d, i) { return i * 10; })
                    .attr("y", function(d) { return y(d.y0 + d.y)+(y(d.y0) - y(d.y0 + d.y))/2 + (maxSizeText * d.y/yStackMaxYear)/2; });

            svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);

            var gy = svg.append("g")
                    .attr("class", "y axis")
                    .call(yAxis);

            makeAxisMinor();

            d3.selectAll("input").on("change", change);

            var timeout = setTimeout(function() {
                d3.select("input[value=\"grouped\"]").property("checked", true).each(change);
            }, 2000);

            function change() {
                clearTimeout(timeout);
                if (this.value === "grouped") transitionGrouped();
                else if(this.value == "relative") transitionRelative();
                else if(this.value == "compare") transitionLineGraph();
                else if(this.value == "stacked")transitionStacked();
            }

            function transitionRelative() {
                if(wasLine) {
                    linesinX();
                    wasLine = false;
                }

                newYAxis(yRelativeMax);

                rect.transition()
                        .duration(500)
                        .delay(function(d, i) { return i * 10; })
                        .attr("y", function(d, i) { return y((d.y0 + d.y)/amountGamesYear[i]*100); })
                        .attr("height", function(d, i) { return y(d.y0/amountGamesYear[i]*100) - y((d.y0 + d.y)/amountGamesYear[i]*100); })
                        .transition()
                        .attr("x", function(d) { return x(d.x); })
                        .attr("width", x.rangeBand());

                var maxSizeTextRel = 20;

                text.transition().duration(400)
                        .delay(function(d, i) { return i * 10; })
                        .attr("x", function(d, i) { return x(d.x) + x.rangeBand()/2-(maxSizeTextRel * (y(d.y0/amountGamesYear[i]*100) - y((d.y0 + d.y)/amountGamesYear[i]*100))/100)/2;})
                        .attr("y", function(d, i) { return (y(d.y0/amountGamesYear[i]*100) - y((d.y0 + d.y)/amountGamesYear[i]*100))/2 + y((d.y0 + d.y)/amountGamesYear[i]*100) + (maxSizeText * d.y/yRelativeMax)/2; })
                        .transition()
                        .duration(400)
                        .style("font-size", function(d,i) {return maxSizeTextRel * (y(d.y0/amountGamesYear[i]*100) - y((d.y0 + d.y)/amountGamesYear[i]*100))/100 + "px"});
            }

            function transitionLineGraph() {
                text.transition()
                        .duration(400)
                        .attr("y", height)
                        .style("font-size", function() {return 0 + "px"});

                rect.transition()
                        .duration(300)
                        .delay(function(d, i) { return i * 10; })
                        .attr("height", function() {return 0;})
                        .attr("y", function() {return height;});

                newYAxis(yCompareMax);

                lines.transition()
                        .duration(600)
                        .delay(function(d, i) { return i * 10; })
                        .attr("d", function(d) { return line(d); })
                        .attr("stroke-width", 2);

                wasLine = true;
            }

            function transitionGrouped() {
                if(wasLine) {
                    linesinX();
                    wasLine = false;
                }
                newYAxis(yGroupMaxYear);

                var widthbar = x.rangeBand() / n;

                rect.transition()
                        .duration(600)
                        .delay(function(d, i) { return i * 10; })
                        .attr("x", function(d, i, j) { return x(d.x) + x.rangeBand() / n * j; })
                        .attr("width", widthbar)
                        .transition()
                        .attr("y", function(d) { return y(d.y); })
                        .attr("height", function(d) { return height - y(d.y); });

                var sizeText = widthbar-2;

                text.transition()
                        .duration(400)
                        .delay(function(d, i) { return i * 10; })
                        .attr("x", function(d, i, j) { return x(d.x) + x.rangeBand() / n * j + widthbar/2 - sizeText/2;})
                        .attr("y", function(d) { return y(d.y)-4 })
                        .transition().duration(400)
                        .style("font-size", function() {return sizeText + "px"})
            }

            function transitionStacked() {
                if(wasLine) {
                    linesinX();
                    wasLine = false;
                }
                newYAxis(yStackMaxYear);

                rect.transition()
                        .duration(600)
                        .delay(function(d, i) { return i * 10; })
                        .attr("y", function(d) { return y(d.y0 + d.y); })
                        .attr("height", function(d) { return y(d.y0) - y(d.y0 + d.y); })
                        .transition()
                        .attr("x", function(d) { return x(d.x); })
                        .attr("width", x.rangeBand());

                text.transition().duration(400)
                        .delay(function(d, i) { return i * 10; })
                        .attr("x", function(d) { return x(d.x) + x.rangeBand()/2-(maxSizeText * d.y/yStackMaxYear)/2;})
                        .attr("y", function(d) { return y(d.y0 + d.y)+(y(d.y0) - y(d.y0 + d.y))/2 + (maxSizeText * d.y/yStackMaxYear)/2; })
                        .transition()
                        .duration(400)
                        .style("font-size", function(d) {return maxSizeText * d.y/yStackMaxYear + "px"});

            }

            function linesinX(){
                lines.transition()
                        .duration(400)
                        .delay(function(d, i) { return i * 20; })
                        .attr("d", function(d) { return lineinX(d); })
                        .attr("stroke-width", 0);
            }

            function newYAxis(maxY) {
                y.domain([0,maxY]);

                yAxis.scale(y);

                gy.transition()
                        .duration(2500)
                        .call(yAxis)
                makeAxisMinor();
            }

            function formatAmount(d) {
                return d === y.domain()[1]
                        ? d + " games"
                        : d;
            }

            function makeAxisMinor() {
                gy.selectAll("g").filter(function(d) { return d; })
                        .classed("minor", true);
            }
        }
        //

    </script>

</body>
</html>
